# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test_mainwidget_2.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# from shutil import copyfile

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from LogUtilClass import LogUtilClass, QMessageLogUtilClass
from UtilClass import UtilClass
from DownloadThreadClass import *
import time
import threading
import os
# import json
# import datetime

abs_dir = os.path.dirname(os.path.abspath(__file__))


class Ui_Form(QWidget):
    receive_signal_dict = {}
    send_signal_dict = {}
    # send_signal_dict['pause_download_signal'] = pyqtSignal(dict) #这里适配一下用dict控制暂停按钮,通过int index_in_download_list来区分
    pause_download_signal = pyqtSignal(dict) #这里适配一下用dict控制暂停按钮
    print(pause_download_signal)

    def __init__(self) -> None:
        super(Ui_Form, self).__init__()
        self.log = LogUtilClass()
        self.save_dir = ""
        self.thread_manager_dict = {} #用于存放线程,避免线程成为局部变量而报错
        self.receive_signal_dict['get_refresh_finish_signal_func'] = self.get_refresh_finish_signal_func
        self.receive_signal_dict['get_download_thread_finish_signal'] = self.get_download_thread_finish_signal
        self.receive_signal_dict['get_collection_info_finish_signal'] = self.get_collection_info_finish_signal
        self.receive_signal_dict['get_single_url_info_finish_signal'] = self.get_single_url_info_finish_signal
        self.receive_signal_dict['get_update_progressbar_signal'] = self.get_update_progressbar_signal
        self.download_list = []
        self.url = "" #QLineEdit的内容
        self.collection_info_list = []
        self.is_multi_thread_download = False
        self.dw_index = 0
        

    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.setWindowIcon(QtGui.QIcon(os.path.join(abs_dir, "icon.ico")))
        Form.resize(800, 400)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.input_url_line = QtWidgets.QLineEdit(Form)
        self.input_url_line.setInputMask("")
        self.input_url_line.setText("")
        self.input_url_line.setObjectName("input_url_line")
        self.horizontalLayout_2.addWidget(self.input_url_line)
        self.single_url_parse_button = QtWidgets.QPushButton(Form)
        self.single_url_parse_button.setObjectName("single_url_parse_button")
        self.horizontalLayout_2.addWidget(self.single_url_parse_button)
        self.collection_url_parse_button = QtWidgets.QPushButton(Form)
        self.collection_url_parse_button.setObjectName("collection_url_parse_button")
        self.horizontalLayout_2.addWidget(self.collection_url_parse_button)
        self.gridLayout.addLayout(self.horizontalLayout_2, 0, 0, 1, 1)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.show_save_location_label = QtWidgets.QLabel(Form)
        self.show_save_location_label.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.show_save_location_label.setText("")
        self.show_save_location_label.setObjectName("show_save_location_label")
        self.horizontalLayout_3.addWidget(self.show_save_location_label)
        self.select_save_location_button = QtWidgets.QPushButton(Form)
        self.select_save_location_button.setObjectName("select_save_location_button")
        self.horizontalLayout_3.addWidget(self.select_save_location_button)
        self.horizontalLayout_3.setStretch(0, 1)
        self.gridLayout.addLayout(self.horizontalLayout_3, 1, 0, 1, 1)
        self.scrollArea = QtWidgets.QScrollArea(Form)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 776, 302))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.downlist_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        self.downlist_label.setStyleSheet("")
        self.downlist_label.setObjectName("downlist_label")
        self.horizontalLayout_4.addWidget(self.downlist_label)
        self.download_all_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.download_all_button.setObjectName("download_all_button")
        self.horizontalLayout_4.addWidget(self.download_all_button)
        self.delete_all_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        self.delete_all_button.setObjectName("delete_all_button")
        self.horizontalLayout_4.addWidget(self.delete_all_button)
        self.horizontalLayout_4.setStretch(0, 5)
        self.verticalLayout_2.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.total_progress_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        self.total_progress_label.setObjectName("total_progress_label")
        self.horizontalLayout_5.addWidget(self.total_progress_label)
        self.total_progressbar = QtWidgets.QProgressBar(self.scrollAreaWidgetContents)
        self.total_progressbar.setProperty("value", 0)
        self.total_progressbar.setObjectName("total_progressbar")
        self.horizontalLayout_5.addWidget(self.total_progressbar)
        self.total_size_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        self.total_size_label.setObjectName("total_size_label")
        self.horizontalLayout_5.addWidget(self.total_size_label)
        self.verticalLayout_2.addLayout(self.horizontalLayout_5)
        self.verticalLayout.addLayout(self.verticalLayout_2)
        self.spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(self.spacerItem)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.gridLayout.addWidget(self.scrollArea, 2, 0, 1, 1)

        self.retranslateUi(Form)
        
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "B站视频下载"))
        self.input_url_line.setPlaceholderText(_translate("Form", "请输入URL"))
        self.single_url_parse_button.setText(_translate("Form", "单视频解析"))
        self.collection_url_parse_button.setText(_translate("Form", "合集解析"))
        self.select_save_location_button.setText(_translate("Form", "选择保存位置"))
        self.downlist_label.setText(_translate("Form", "下载列表"))
        self.download_all_button.setText(_translate("Form", "下载全部"))
        self.delete_all_button.setText(_translate("Form", "删除全部"))
        self.total_progress_label.setText(_translate("Form", "总进度"))
        self.total_size_label.setText(_translate("Form", "1.0K/5.0M"))
        #==============
        self.total_size_label.setVisible(False)
        self.total_progress_label.setVisible(False)
        self.total_progressbar.setVisible(False)
        #===============
        #链接按钮
        self.single_url_parse_button.clicked.connect(self.parse_single_url)
        self.select_save_location_button.clicked.connect(self.select_save_folder)
        self.collection_url_parse_button.clicked.connect(self.parse_collection_url)
        self.download_all_button.clicked.connect(self.download_all_url)
        self.delete_all_button.clicked.connect(self.delete_all_info)
        
    
    def parse_single_url(self):
        self.url = self.input_url_line.text()
        print(self.url)
        if self.url.isspace() or self.url=="" or len(self.url)==0:
            QMessageLogUtilClass().show("提示","URL不能为空")
            return
        # if not self.save_dir or self.save_dir.isspace() :
        #     QMessageLogUtilClass().show("提示","请选择保存地址")
        #     return

        #先检查一下时候有重复的下载解析结果
        for index, horizontallayout_dict in enumerate(self.download_list):
            parse_single_url = horizontallayout_dict['parse_single_url']
            parse_collection_url = horizontallayout_dict['parse_collection_url']
            title = horizontallayout_dict['prime_download_info_dict']['title']
            if self.url == parse_single_url or self.url == parse_collection_url:
                user_choice = QMessageLogUtilClass(set_cancel_button=True).show("提示","该链接已经解析过,是否删除原解析结果?")
                if user_choice == QMessageBox.Ok:
                    # self.download_list.pop(index)
                    # del horizontallayout_dict
                    #同时删除页面布局本身的布局控件
                    # self.delete_horizonlayout(index) #先删除再pop，因为该方法需要self.downlod_lsit中的信息。
                    self.download_list.pop(index)
                    horizontallayout = horizontallayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
                    self.delete_horizonlayout(horizontallayout)
                    del horizontallayout_dict
                    # self.delete_record
                    # print(horizontallayout_dict)
                    # return
                    break
                else:
                    return
        #刷新下载列表
        #先禁用按钮
        self.single_url_parse_button.setEnabled(False) #后面获取结束信号在恢复
        self.refresh_download_list()

        # #将解析工作放到线程中进行
        # timestamp = time.time()
        # downloadthread = DownloadThread(click_index=timestamp, url=self.url, options="get_single_url_info")
        # downloadthread_dict = {}
        # downloadthread_dict['options'] = "get_single_url_info"
        # downloadthread_dict['index'] = len(self.download_list)
        # downloadthread_dict['thread'] = downloadthread
        # downloadthread_dict['url'] = self.url
        # downloadthread_dict['timestamp'] = timestamp #唯一标识
        # self.thread_manager_dict[downloadthread_dict['timestamp']] = downloadthread_dict #用字典方便查找，后续删除也方便。
        # #链接信号
        # downloadthread.send_single_url_info_finish_signal.connect(self.get_single_url_info_finish_signal)
        # #开启线程
        # self.thread_manager_dict[timestamp]['thread'].start()
        #结束，等信号
        return
        
    def parse_collection_url(self):
        #首先清除download_list
        self.delete_all_info()
        self.log.info("开始解析合集")
        input_collection_url = self.input_url_line.text()
        time_stamp = int(time.time())
        parse_collection_thread = DownloadThread(time_stamp, collection_url=input_collection_url,\
                                                download_file_type="collection_parse")
        #链接解析完成信号
        parse_collection_thread.parse_collection_finish_signal.connect(self.get_parse_collection_finish_signal)
        #禁用所有按钮,等待解析完毕
        self.disable_or_enable_widgets(False)
        #将线程加入manager
        downloadthread_dict = {}
        downloadthread_dict['options'] = "collection_parse"
        downloadthread_dict['index'] = len(self.download_list)
        downloadthread_dict['thread'] = parse_collection_thread
        downloadthread_dict['url'] = self.url
        downloadthread_dict['timestamp'] = time_stamp #唯一标识
        self.thread_manager_dict[downloadthread_dict['timestamp']] = downloadthread_dict #用字典方便查找，后续删除也方便。
        #链接信号
        parse_collection_thread.send_single_url_info_finish_signal.connect(self.get_single_url_info_finish_signal)
        #开启线程
        self.thread_manager_dict[time_stamp]['thread'].start()

        return

    def download_all_url1(self): #测试用
        pass
        print(len(self.thread_manager_dict))
        print(len(self.download_list))
    
    def download_all_url2(self):
        #先检查文件是否又savev_path
        if self.save_dir == "":
            self.log.error("请先设置保存路径")
            QMessageLogUtilClass().show("提示","请选择保存地址")
            return
        pass
        print(len(self.thread_manager_dict))
        print(len(self.download_list))
        self.multi_dw_keys = []
        for key in self.thread_manager_dict.keys():
            if len(str(key).split('-')) ==2:
                if str(key).split('-')[1] == "download_thread":
                    self.multi_dw_keys.append(key)
        if len(self.multi_dw_keys) == 0:
            self.log.error("当前没有下载线程")
            return
        self.is_multi_thread_download = True
        self.log.debug(f"keys: {self.multi_dw_keys}")
        # return
        len1 = 2 if len(self.multi_dw_keys)>=2 else 1
        for i in range(len1):
            # self.thread_manager_dict[self.multi_dw_keys[i]]['thread'].start()
            # self.pause_download_signal.emit({})
            self.log.info(f"开始下载第{i}个线程")
            index_in_download_list = self.thread_manager_dict[self.multi_dw_keys[i]]['index']
            self.start_or_pause_download_when_multi_thread(index_in_download_list)

    def download_all_url(self):
        #先检查文件是否又savev_path
        if self.save_dir == "":
            self.log.error("请先设置保存路径")
            QMessageLogUtilClass().show("提示","请选择保存地址")
            return
        pass
        print(len(self.thread_manager_dict))
        print(len(self.download_list))
        self.multi_dw_keys = []
        
        # return
        self.max_thread = 3 if len(self.download_list)>=3 else 1
        self.dw_index = 0
        self.is_multi_thread_download = True
        len1 = 2 if len(self.download_list)>=2 else 1
        for i in range(self.max_thread):
            # self.dw_index+=1
            self.start_or_pause_download_when_multi_thread(self.dw_index)
            self.dw_index+=1
            

    def delete_all_info(self):
        #直接删除所有layout，清空self.thread_manager_dict
        
        for index, horizontallayout_dict in enumerate(self.download_list):
            horizontallayout = horizontallayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
            self.delete_horizonlayout(horizontallayout)
            # self.download_list.remove(horizontallayout_dict)
            self.download_list[index] = None
            del horizontallayout_dict
        #清空self.thread_manager_dict
        keys = list(self.thread_manager_dict.keys())
        for key in keys:
            thread_to_destroy = self.thread_manager_dict.get(key)['thread']
            # del thread_to_destroy
            del self.thread_manager_dict[key]
            # 终止线程
            thread_to_destroy.terminate()
            # 检查线程的状态
            if thread_to_destroy.isFinished() or True: #没结束也删除
                self.log.error(f"线程{thread_to_destroy}已经结束")
                # 销毁线程对象
                thread_to_destroy.deleteLater()
            # break
        self.download_list=[]
        self.log.info("删除所有下载信息")
        # print(self.thread_manager_dict)
        print(self.download_list)

    def parse_per_url_in_collection_list(self):
        pass
        # for index, per_url_info_dict in enumerate(self.collection_info_list):
        #     url = per_url_info_dict['url']
        #     print(f"当前url : {url}")
            # time.sleep(1)
            #先检查一下时候有重复的下载解析结果
        for index, horizontallayout_dict in enumerate(self.download_list):
            parse_single_url = horizontallayout_dict['parse_single_url']
            parse_collection_url = horizontallayout_dict['parse_collection_url']
            if self.url == parse_single_url or self.url == parse_collection_url:
                # user_choice = QMessageLogUtilClass(set_cancel_button=True).show("提示","该链接已经解析过,是否删除原解析结果?")
                if True:
                    self.download_list.pop(index)
                    horizontallayout = horizontallayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
                    self.delete_horizonlayout(horizontallayout)
                    del horizontallayout_dict
                    break
                else:
                    return
        #刷新下载列表
        #先禁用按钮
        self.disable_or_enable_widgets(False) #后面获取结束信号在恢复
        self.refresh_download_list_when_parse_collection(index_in_collection=0)

    def add_progress_layout(self, single_url_info_dict ={}):
        self.log.info("开始添加progress布局")
        # 先移除 弹簧
        self.verticalLayout.removeItem(self.spacerItem)
        horizontalLayout = QtWidgets.QHBoxLayout()
        horizontalLayout.setObjectName("horizontalLayout")
        title_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(title_label.sizePolicy().hasHeightForWidth())
        title_label.setSizePolicy(sizePolicy)
        title_label.setObjectName("title_label")
        horizontalLayout.addWidget(title_label)
        progressBar = QtWidgets.QProgressBar(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(progressBar.sizePolicy().hasHeightForWidth())
        progressBar.setSizePolicy(sizePolicy)
        progressBar.setProperty("value", 0)
        progressBar.setObjectName("progressBar")
        horizontalLayout.addWidget(progressBar)
        progress_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(progress_label.sizePolicy().hasHeightForWidth())
        progress_label.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setPointSize(9)
        progress_label.setFont(font)
        progress_label.setTextFormat(QtCore.Qt.AutoText)
        progress_label.setScaledContents(False)
        progress_label.setObjectName("progress_label")
        horizontalLayout.addWidget(progress_label)
        start_or_pause_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(start_or_pause_button.sizePolicy().hasHeightForWidth())
        start_or_pause_button.setSizePolicy(sizePolicy)
        start_or_pause_button.setObjectName("start_or_pause_button")
        horizontalLayout.addWidget(start_or_pause_button)
        comboBox = QtWidgets.QComboBox(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(comboBox.sizePolicy().hasHeightForWidth())
        comboBox.setSizePolicy(sizePolicy)
        comboBox.setEditable(True)
        comboBox.setObjectName("comboBox")
        comboBox.addItem("")
        horizontalLayout.addWidget(comboBox)
        delete_button = QtWidgets.QPushButton(self.scrollAreaWidgetContents)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(delete_button.sizePolicy().hasHeightForWidth())
        delete_button.setSizePolicy(sizePolicy)
        delete_button.setContextMenuPolicy(QtCore.Qt.DefaultContextMenu)
        delete_button.setObjectName("delete_button")
        horizontalLayout.addWidget(delete_button)
        horizontalLayout.setStretch(0, 4)
        horizontalLayout.setStretch(1, 10)
        horizontalLayout.setStretch(2, 3)
        horizontalLayout.setStretch(3, 3)
        horizontalLayout.setStretch(4, 4)
        horizontalLayout.setStretch(5, 3)
        comboBox.setCurrentIndex(0)
        self.verticalLayout.addLayout(horizontalLayout)
        #设置控件样式
        _translate = QtCore.QCoreApplication.translate
        title_label.setText(_translate("Form", "TextLabel"))
        progress_label.setText(_translate("Form", "1.0K/5.0M"))
        start_or_pause_button.setText(_translate("Form", "开始下载"))
        comboBox.setCurrentText(_translate("Form", "视频质量"))
        comboBox.setItemText(0, _translate("Form", "视频质量选择"))
        delete_button.setText(_translate("Form", "删除记录"))
        #再添加弹簧
        self.verticalLayout.addItem(self.spacerItem)
        #设置一个字典来存储这个水平布局
        #获取时间戳作为线程唯一标识
        time_stamp = int(time.time())
        this_horizontalLayout_dict = {}
        this_horizontalLayout_layout_dict = {} #用于存放所有布局和控件
        this_horizontalLayout_layout_dict['horizontalLayout'] = horizontalLayout
        this_horizontalLayout_layout_dict['title_label'] = title_label
        this_horizontalLayout_layout_dict['progressBar'] = progressBar
        this_horizontalLayout_layout_dict['progress_label'] = progress_label
        this_horizontalLayout_layout_dict['start_or_pause_button'] = start_or_pause_button
        this_horizontalLayout_layout_dict['comboBox'] = comboBox
        this_horizontalLayout_layout_dict['delete_button'] = delete_button
        this_horizontalLayout_dict['this_horizontalLayout_layout_dict'] = this_horizontalLayout_layout_dict
        this_horizontalLayout_dict['download_info_dict'] = single_url_info_dict #完整的下载信息
        this_horizontalLayout_dict['download_thread'] = None #下载线程
        this_horizontalLayout_dict['prime_download_info_dict'] = None #优先选择的下载信息
        this_horizontalLayout_dict['download_status_info_dict'] = None #用于存储下载状态的字典
        this_horizontalLayout_dict['this_horizontalLayout_create_time'] = time_stamp #用时间戳来唯一标识这个水平布局
        this_horizontalLayout_dict['index_in_download_list'] = None #用于表示再下载列表中的位置
        this_horizontalLayout_dict['receive_signal_handler_func_dict'] = self.receive_signal_dict #用于存储信号处理函数的字典
        this_horizontalLayout_dict['send_signal_dict'] = self.send_signal_dict #用于存储信号的字典
        this_horizontalLayout_dict['save_dir'] = self.save_dir #用于存储错误信息
        this_horizontalLayout_dict['parse_single_url'] = single_url_info_dict['parse_single_url'] #记录用于解析的url
        this_horizontalLayout_dict['parse_collection_url'] = single_url_info_dict['parse_collection_url'] #用于解析合集的url
        this_horizontalLayout_dict['err_dict'] = None #用于存储错误信息
        time.sleep(0.01)  #这里确保时间戳的唯一性
        #然后进行按钮的链接
        start_or_pause_button.clicked.connect(self.start_or_pause_download)
        delete_button.clicked.connect(self.delete_record)
        comboBox.currentIndexChanged.connect(self.select_video_quality)
        comboBox.setEditable(False)
        #然后将this_horizontalLayout_dict添加到self.download_list中
        index_in_download_list = len(self.download_list)
        this_horizontalLayout_dict['index_in_download_list'] = index_in_download_list
        self.download_list.append(this_horizontalLayout_dict)
        self.log.info("progress布局加入到了self.dowload_list")
        # self.download_list[0].hide()
        #先隐藏布局控件
        for index in range(0, horizontalLayout.count()):
            item = horizontalLayout.itemAt(index)
            widget_item = item.widget()
            widget_item.setVisible(False)
        # #获取时间戳作为线程唯一标识
        # time_stamp = time.time()
        options="arrange_horizontallayout_in_downloadlist"
        #然后开一个线程对horizontalLayout的dict进行完善，完善后再显示它
        utilclass_thread = UtilClass(index=time_stamp, download_list=self.download_list, horizontaldict=self.download_list[-1],\
                                    options=options, thread_manager_dict=self.thread_manager_dict, \
                                    pause_download_signal=self.pause_download_signal, save_dir=self.save_dir)
        #链接线程结束信号
        utilclass_thread.ARRANGE_HORIZONTALLAYOUT_IN_DOWNLOADLIST.connect(self.get_arrage_finish_signal)
        # self.pause_download_signal.connect(utilclass_thread.temp_pause_download_signal) #这里单独设置与downloaad_theread的连接了
        #加入线程manager
        utilclass_thread_dict = {}
        utilclass_thread_dict['options'] = "get_single_url_info"
        utilclass_thread_dict['index'] = len(self.download_list)
        utilclass_thread_dict['thread'] = utilclass_thread
        utilclass_thread_dict['url'] = self.url
        utilclass_thread_dict['timestamp'] = time_stamp #唯一标识
        self.thread_manager_dict[time_stamp] = utilclass_thread_dict
        #然后开启线程
        self.thread_manager_dict[time_stamp]['thread'].start()
        # self.log.debug(f"self.thread_manager_dict为: {self.thread_manager_dict}")
        self.log.debug(f"self.thread_manager_dict长度为: {len(self.thread_manager_dict)}")
        return this_horizontalLayout_dict

    def start_or_pause_download_when_multi_thread(self, index_in_download_list):
        self.log.error(index_in_download_list)
        # #先检查文件是否又savev_path
        # if self.save_dir == "":
        #     self.log.error("请先设置保存路径")
        #     QMessageLogUtilClass().show("提示","请选择保存地址")
        #     return
        try:
            click_button_index_in_download_list = index_in_download_list
            
            this_horizontalLayout_dict = self.download_list[click_button_index_in_download_list]
            # self.log.error(this_horizontalLayout_dict['send_signal_dict'])
            this_horizontalLayout_layout_dict = this_horizontalLayout_dict['this_horizontalLayout_layout_dict']
            this_horizontalLayout = this_horizontalLayout_layout_dict['horizontalLayout']
            this_button = this_horizontalLayout_layout_dict['start_or_pause_button']
            click_button_time_stamp = int(this_button.objectName().split("-")[1])
            if this_button.text() == "下载完成":
                # self.get_update_progressbar_signal({"end":0},click_button_time_stamp)
                self.dw_index+=1
                if self.dw_index == len(self.download_list):
                    QMessageLogUtilClass().show("提示","没有可下载的")
                    return
                this_horizontalLayout_dict = self.download_list[self.dw_index]
                # self.log.error(this_horizontalLayout_dict['send_signal_dict'])
                this_horizontalLayout_layout_dict = this_horizontalLayout_dict['this_horizontalLayout_layout_dict']
                this_horizontalLayout = this_horizontalLayout_layout_dict['horizontalLayout']
                this_button = this_horizontalLayout_layout_dict['start_or_pause_button']
                click_button_time_stamp = int(this_button.objectName().split("-")[1])
        except Exception as e:
            self.log.error(e)
            # return
        # print(self.thread_manager_dict[str(click_button_time_stamp)+'-download_thread']['thread'])
        
        # return
        #获取当前下载状态dict
        download_status_info_dict = this_horizontalLayout_dict['download_status_info_dict']
        is_Start = download_status_info_dict['is_Start']
        is_Paused = download_status_info_dict['is_Paused']
        is_End = download_status_info_dict['is_End']

        #检测文件是否存在
        save_path = this_horizontalLayout_dict['prime_download_info_dict']['save_path']
        temp_video_save_path = save_path.strip('mp4')+"tempmp4"
        temp_audio_save_path = save_path +"tempmp3"
        # temp_audio_save_path = save_path.replace(' ','_')
        if os.path.exists(save_path) or os.path.exists(temp_video_save_path) or os.path.exists(temp_audio_save_path):
            self.log.warning(f"文件{save_path}已经存在，将覆盖原文件")
            # user_choice = QMessageLogUtilClass(set_cancel_button=True).show("提示","文件已经存在，是否覆盖原文件?")
            if True: #不问了直接删除
                if os.path.exists(save_path):
                    os.remove(save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                if os.path.exists(temp_video_save_path):
                    os.remove(temp_video_save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                if os.path.exists(temp_audio_save_path):
                    os.remove(temp_audio_save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                while(os.path.exists(save_path) or os.path.exists(temp_video_save_path) or os.path.exists(temp_audio_save_path)):
                    print("还没删除完")
            else:
                return

        #判断
        new_button_text = ""
        download_thread = this_horizontalLayout_dict['download_thread'] #获取对应的下载线程
        self.log.warning(is_Start)
        if not is_Start: #说明没开始下载过
            if is_Paused: #说明还是暂停状态
                is_Start = True
                is_Paused = False
                new_button_text = "暂停下载"
            else:
                is_Start = True
                is_Paused = False
                new_button_text = "开始下载"
            #如果is_start为false，说明还没开始下载，同时this_horizontal的download_thread开没有开启，即没有start
            #所以则例需要start
            # download_thread = this_horizontalLayout_dict['download_thread']
            # download_thread.start()  #最好别在这启动，因为线程检测到is_pause为true，就停止了
            # self.pause_download_signal.connect(download_thread.get_pause_download_signal)
            #只有开启了线程,才能执行run代码，也就是线程中运行代码
        else:
            if is_Paused: #说名是开始之后暂停的
                is_Paused = False
                new_button_text = "暂停下载"
            else:
                is_Paused = True
                new_button_text = "继续下载"
        if new_button_text == "":
            return
        #然后就是判断 new_button_text 是否为继续下载，如果是，表示暂停了下载，这里就需要重新更新一下下载线程
        #这里的做法就是重新创建一个线程,放在一个方法中去执行 直接用 set_per_url_download_thread
        self.log.warning(new_button_text)
        if new_button_text == "继续下载":
            #首先将原来的线程删除
            index_in_download_list = this_horizontalLayout_dict["index_in_download_list"]
            ds_download_thread_dict = self.thread_manager_dict[str(click_button_time_stamp) + "-download_thread"]
            ds_download_thread = ds_download_thread_dict['thread']
            ds_download_thread.terminate()
            if ds_download_thread.isFinished():
                self.log.debug("线程已经结束")
                self.thread_manager_dict.pop(str(click_button_time_stamp) + "-download_thread")
                ds_download_thread.deleteLater()
            self.set_per_url_download_thread(index_in_download_list)
            # this_horizontalLayout_dict['download_thread']
        #然后设置一下按钮的text
        this_horizontalLayout_layout_dict['start_or_pause_button'].setText(new_button_text)
        #更新一下状态
        new_status_dict = {
            "is_Start":is_Start,
            "is_End":is_End,
            "is_Paused":is_Paused,
        }
        this_horizontalLayout_dict['download_status_info_dict'] = new_status_dict
        if is_Paused:
            #发送信号给下载线程,这里使用的click_index为horizontallayout的time_stamp唯一标识
            self.pause_download_signal.emit({
                "click_index": click_button_time_stamp,
                "is_pause":True
            })
            #先发送暂停信号,再开启线程
            return #直接return
        else:
            #发送开始信号，开始下载
            self.pause_download_signal.emit({
                "click_index": click_button_time_stamp,
                "is_pause":False
            })
            self.log.warning("开始线程")
            download_thread.start() #发送开始信号，开始下载
        #更新按钮文本
        
        self.log.error(f"开始设置buttonnew_button_text{new_button_text}")
        this_button.setText(new_button_text)
            
        return

    def start_or_pause_download(self):
        #先检查文件是否又savev_path
        if self.save_dir == "":
            self.log.error("请先设置保存路径")
            QMessageLogUtilClass().show("提示","请选择保存地址")
            return
        #检测文件是否存在
        sender = app.sender()  # 获取发送信号的控件
        if isinstance(sender, QPushButton):
            button_name = sender.objectName()
            print("当前点击的按钮:", button_name)
            self.log.debug(f"self.thread_manager_dict的线程数量: {len(self.thread_manager_dict)}")
            # print(self.thread_manager_dict[key]['thread'] for key in self.thread_manager_dict.keys())
            
            # return
            click_button_time_stamp = int(button_name.split("-")[1])
            click_button_index_in_download_list = int(button_name.split("-")[-1])
            print(self.thread_manager_dict[str(click_button_time_stamp)+'-download_thread']['thread'])
            
            #根据索引获取horizontalLayout
            this_horizontalLayout_dict = self.download_list[click_button_index_in_download_list]
            # self.log.error(this_horizontalLayout_dict['send_signal_dict'])
            # self.log.error(this_horizontalLayout_dict['send_signal_dict']['pause_download_signal'])
            # send_pause_download_signal = this_horizontalLayout_dict['send_signal_dict']['pause_download_signal']
            # self.log.error(send_pause_download_signal)
            this_horizontalLayout_layout_dict = this_horizontalLayout_dict['this_horizontalLayout_layout_dict']
            this_horizontalLayout = this_horizontalLayout_layout_dict['horizontalLayout']
            this_button = this_horizontalLayout_layout_dict['start_or_pause_button']
            # this_button.setText("暂停下载")
            # return
            #获取当前下载状态dict
            download_status_info_dict = this_horizontalLayout_dict['download_status_info_dict']
            is_Start = download_status_info_dict['is_Start']
            is_Paused = download_status_info_dict['is_Paused']
            is_End = download_status_info_dict['is_End']

            #检测文件是否存在
            save_path = this_horizontalLayout_dict['prime_download_info_dict']['save_path']
            temp_video_save_path = save_path.strip('mp4')+"tempmp4"
            temp_audio_save_path = save_path +"tempmp3"
            # temp_audio_save_path = save_path.replace(' ','_')
            if not is_Start:
                if os.path.exists(save_path) or os.path.exists(temp_video_save_path) or os.path.exists(temp_audio_save_path):
                    self.log.warning(f"文件{save_path}已经存在，将覆盖原文件")
                    user_choice = QMessageLogUtilClass(set_cancel_button=True).show("提示","文件已经存在，是否覆盖原文件?")
                    if user_choice == QMessageBox.Ok:
                        if os.path.exists(save_path):
                            os.remove(save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                        if os.path.exists(temp_video_save_path):
                            os.remove(temp_video_save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                        if os.path.exists(temp_audio_save_path):
                            os.remove(temp_audio_save_path) #这里删除文件也需要时间,要注意开启下载线程的实际,避免冲突
                        while(os.path.exists(save_path) or os.path.exists(temp_video_save_path) or os.path.exists(temp_audio_save_path)):
                            print("还没删除完")
                    else:
                        return

            #判断
            new_button_text = ""
            download_thread = this_horizontalLayout_dict['download_thread'] #获取对应的下载线程
            if not is_Start: #说明没开始下载过
                if is_Paused: #说明还是暂停状态
                    is_Start = True
                    is_Paused = False
                    new_button_text = "暂停下载"
                else:
                    is_Start = True
                    is_Paused = False
                    new_button_text = "开始下载"
                #如果is_start为false，说明还没开始下载，同时this_horizontal的download_thread开没有开启，即没有start
                #所以则例需要start
                # download_thread = this_horizontalLayout_dict['download_thread']
                # download_thread.start()  #最好别在这启动，因为线程检测到is_pause为true，就停止了
                # self.pause_download_signal.connect(download_thread.get_pause_download_signal)
                #只有开启了线程,才能执行run代码，也就是线程中运行代码
            else:
                if is_Paused: #说名是开始之后暂停的
                    is_Paused = False
                    new_button_text = "暂停下载"
                else:
                    is_Paused = True
                    new_button_text = "继续下载"
            if new_button_text == "":
                return
            #然后就是判断 new_button_text 是否为继续下载，如果是，表示暂停了下载，这里就需要重新更新一下下载线程
            #这里的做法就是重新创建一个线程,放在一个方法中去执行 直接用 set_per_url_download_thread
            if new_button_text == "继续下载":
                #首先将原来的线程删除
                index_in_download_list = this_horizontalLayout_dict["index_in_download_list"]
                ds_download_thread_dict = self.thread_manager_dict[str(click_button_time_stamp) + "-download_thread"]
                ds_download_thread = ds_download_thread_dict['thread']
                ds_download_thread.progressChanged_signal.disconnect()
                ds_download_thread.terminate()
                if ds_download_thread.isFinished():
                    self.log.debug("线程已经结束")
                    self.thread_manager_dict.pop(str(click_button_time_stamp) + "-download_thread")
                    ds_download_thread.deleteLater()
                    del ds_download_thread
                    # print(self.thread_manager_dict[str(click_button_time_stamp) + "-download_thread"])
                    self.set_per_url_download_thread(index_in_download_list)
                # this_horizontalLayout_dict['download_thread']
            #然后设置一下按钮的text
            this_horizontalLayout_layout_dict['start_or_pause_button'].setText(new_button_text)
            #更新一下状态
            new_status_dict = {
                "is_Start":is_Start,
                "is_End":is_End,
                "is_Paused":is_Paused,
            }
            this_horizontalLayout_dict['download_status_info_dict'] = new_status_dict
            if is_Paused:
                #发送信号给下载线程,这里使用的click_index为horizontallayout的time_stamp唯一标识
                self.pause_download_signal.emit({
                    "click_index": click_button_time_stamp,
                    "is_pause":True
                })
                #先发送暂停信号,再开启线程
                return #直接return
            else:
                #发送开始信号，开始下载
                self.pause_download_signal.emit({
                    "click_index": click_button_time_stamp,
                    "is_pause":False
                })
                download_thread.start() #发送开始信号，开始下载
            #更新按钮文本
            
            self.log.error(f"开始设置buttonnew_button_text{new_button_text}")
            this_button.setText(new_button_text)
            
        return

    def delete_record(self):
        sender = app.sender()  # 获取发送信号的控件
        print("delete_button被点击")
        self.log.info(f"当前self.thread_mangeer_dic的长度为 {len(self.thread_manager_dict)}")
        self.log.info(f"当前self.cllection的长度为 {len(self.collection_info_list)}")
        #显示一下
        for key in self.thread_manager_dict.keys():
            print(key, (self.thread_manager_dict[key]['options']))
        if isinstance(sender, QPushButton):
            button_name = sender.objectName()
            # print("当前点击的删除按钮:", button_name)
            click_button_time_stamp = int(button_name.split("-")[1])
            click_button_index_in_download_list = int(button_name.split("-")[-1])
            self.log.debug(f"当前点击的删除按钮:{click_button_index_in_download_list}")
            click_horizontalLayout_dict = self.download_list[click_button_index_in_download_list]
            click_horizontalLayout = click_horizontalLayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
            this_delete_button = click_horizontalLayout_dict['this_horizontalLayout_layout_dict']['delete_button']
            this_delete_button.setEnabled(False)
            #找到控件之后就可以pop了
            self.download_list.pop(click_button_index_in_download_list)
            del click_horizontalLayout_dict
            self.delete_horizonlayout(click_horizontalLayout)

            #然后将对应的download_thread也删除
            for key,value in self.thread_manager_dict.items():
                if int(float(str(key).split("-")[0])) == int(click_button_time_stamp):
                    thread_to_destroy = self.thread_manager_dict.get(key)['thread']
                    # del thread_to_destroy
                    del self.thread_manager_dict[key]
                    # 终止线程
                    thread_to_destroy.terminate()
                    # 检查线程的状态
                    if thread_to_destroy.isFinished():
                        self.log.error(f"线程{thread_to_destroy}已经结束")
                        # 销毁线程对象
                        thread_to_destroy.deleteLater()
                    break
        #===============================================================================
            # click_horizontalLayout_dict = self.download_list[click_button_index_in_download_list]
            # click_horizontalLayout = click_horizontalLayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
            # self.log.debug(f"当前点击的删除按钮:{click_button_index_in_download_list}")
            # #找到之后就和义pop了

            # # self.log.warning(f"之前的downloadlist:{self.download_list}")
            # print(click_button_index_in_download_list)
            # self.log.debug(f"当前下载列表长度为{len(self.download_list)}")
            # self.download_list.pop(click_button_index_in_download_list)
            # self.log.debug(f"当前下载列表长度为{len(self.download_list)}")
            # # self.log.warning(f"之后的downloadlist:{self.download_list}")
            # while click_horizontalLayout.count():
            #     item = click_horizontalLayout.takeAt(0)
            #     widget_item = item.widget()
            #     if isinstance(widget_item, QLabel):
            #         pass
            #         # print(widget_item.objectName())
            #     if widget_item:
            #         widget_item.deleteLater()
            # # 删除布局对象
            # del click_horizontalLayout
        #========================================
        else:
            self.log.error("未找到当前按钮")
        self.log.warning(f"当前下载列表i哦长度为{len(self.download_list)}")
        #然后refresh一下downloadlist
        options="refresh_download_list"
        #然后开一个线程对horizontalLayout的dict进行完善，完善后再显示它
        time_stamp = int(time.time())
        utilclass_thread = UtilClass(index=time_stamp, download_list=self.download_list,\
                                    options=options,)
        #链接线程结束信号
        utilclass_thread.REFRESH_DOWNLOAD_LIST_FINISH_SIGNAL.connect(self.get_refresh_download_list_signal)
        # self.pause_download_signal.connect(utilclass_thread.temp_pause_download_signal) #这里单独设置与downloaad_theread的连接了
        #加入线程manager
        utilclass_thread_dict = {}
        utilclass_thread_dict['options'] = "refresh_download_list"
        utilclass_thread_dict['index'] = len(self.download_list)
        utilclass_thread_dict['thread'] = utilclass_thread
        utilclass_thread_dict['url'] = self.url
        utilclass_thread_dict['timestamp'] = time_stamp #唯一标识
        self.thread_manager_dict[str(time_stamp)+"-refresh_download_list_thread"] = utilclass_thread_dict
        #然后开启线程
        self.thread_manager_dict[str(time_stamp)+"-refresh_download_list_thread"]['thread'].start()
        # self.log.debug(f"self.thread_manager_dict为: {self.thread_manager_dict}")
        return
    
    def delete_horizonlayout(self,horizonlayout):
        pass
        # click_horizontalLayout_dict = self.download_list[index_in_download_list]
        # click_horizontalLayout = click_horizontalLayout_dict['this_horizontalLayout_layout_dict']['horizontalLayout']
        # self.log.debug(f"当前点击的删除按钮:{index_in_download_list}")
        #找到之后就和义pop了

        # self.log.warning(f"之前的downloadlist:{self.download_list}")
        # print(index_in_download_list)
        # self.log.debug(f"当前下载列表长度为{len(self.download_list)}")
        # self.download_list.pop(index_in_download_list)
        # self.log.debug(f"当前下载列表长度为{len(self.download_list)}")
        # self.log.warning(f"之后的downloadlist:{self.download_list}")
        while horizonlayout.count():
            item = horizonlayout.takeAt(0)
            widget_item = item.widget()
            if isinstance(widget_item, QLabel):
                pass
                # print(widget_item.objectName())
            if widget_item:
                self.log.warning(f"删除了{widget_item.objectName()}")
                widget_item.deleteLater()
        # 删除布局对象
        del horizonlayout

    #禁用所有控件,或者开启
    def disable_or_enable_widgets(self, IS_DISABLE):
        if isinstance(self, QWidget):
            self.log.warning("开始禁用")
            #先禁用几个按钮
            self.single_url_parse_button.setEnabled(IS_DISABLE)
            self.collection_url_parse_button.setEnabled(IS_DISABLE)
            self.download_all_button.setEnabled(IS_DISABLE)
            self.delete_all_button.setEnabled(IS_DISABLE)
            self.select_save_location_button.setEnabled(IS_DISABLE)
            #然后download_lsit中的button
            for i, horizontaldict in enumerate(self.download_list):
                horizonlayout_dict = horizontaldict['this_horizontalLayout_layout_dict']
                start_or_pause_button = horizonlayout_dict['start_or_pause_button']
                delete_button = horizonlayout_dict['delete_button']
                start_or_pause_button.setEnabled(IS_DISABLE)
                delete_button.setEnabled(IS_DISABLE)

            # self.setEnabled(False)
            #
            # expression = QRegExp(u'horizontalLayout*')
            # print(self.findChildren(QBoxLayout,"horizontalLayout"))
            # for child in self.findChildren(QPushButton):
            #     print(child)
            #     if isinstance(child, QPushButton):
            #         print(f"找到button{child}")
            #         child.setEnabled(False)
        # for i in range(self.count()):
        #     item = self.itemAt(i)
        #     item.setEnabled(False)
        # return
        #================
            # if isinstance(item, QGroupBox):
            #     disable_widgets(item.layout())
            # elif isinstance(item, QWidget):
            #     item.setEnabled(False)
            # elif isinstance(item, QLabel):
            #     item.setEnabled(False)
            # elif isinstance(item, QLineEdit):
            #     item.setEnabled(False)
            # elif isinstance(item, QPushButton):
            #     item.setEnabled(False)
            # else:
            #     disable_widgets(item.layout())
    def enable_widgets(self):
        if isinstance(self, QWidget):
            # self.setEnabled(False)
            for child in self.findChildren(QWidget):
                if isinstance(child, QPushButton):
                    child.setEnabled(True)
            
    def select_save_folder(self):
        folder_path = QFileDialog.getExistingDirectory(self, "选择文件夹", "/")
        # print(self)
        if folder_path:
            self.show_save_location_label.setText(folder_path)
            self.save_dir = folder_path
            # with open(os.path.join(abs_dir, "config.json"), "w", encoding='utf-8') as f:
            #     f.write(json.dumps({"save_dir": self.save_dir}))
        else:
            self.show_save_location_label.setText("未选择文件夹")   
        #这里需要修复一个bug，就是如果在解析的时候没有选择save_foler，也就是self.save_dir=""，那么解析后的各个horizontallayout
        #对应的下载save_dir就是文件名本身，所以这里需要对horizontallayou的save_dir进行一个检查更新
        #考虑到又多个layout的情况，这里就用线程进行更新
        time_stamp_of_util_thread = int(time.time())
        util_thread =UtilClass(options="refresh_save_path", download_list=self.download_list,\
                               save_dir=self.save_dir, index=time_stamp_of_util_thread)
        #将线程加入manager
        
        util_thread_dict = {}
        util_thread_dict['options'] = "download_thread"
        util_thread_dict['index'] = "?"
        util_thread_dict['thread'] = util_thread
        util_thread_dict['url'] = ""
        util_thread_dict['timestamp'] = time_stamp_of_util_thread #唯一标识
        self.thread_manager_dict[str(time_stamp_of_util_thread)+'-'+"refresh_save_path_util_thread"] = util_thread_dict
        util_thread.REFRESH_SAVE_PATH_FINISH_SIGNAL.connect(self.get_refresh_save_path_signal)
        #这里需要先禁用一下所有按钮,等更新完保存未知后再开启
        self.disable_or_enable_widgets(False)
        util_thread.start()
    
    def select_video_quality(self):
        #检测文件是否存在
        sender = app.sender()  # 获取发送信号的控件
        if isinstance(sender, QComboBox):
            combobox_name = sender.objectName()
            print("当前点击的combobox:", combobox_name)
            # return
            self.log.debug(f"self.thread_manager_dict的线程数量: {len(self.thread_manager_dict)}")
            # print(self.thread_manager_dict[key]['thread'] for key in self.thread_manager_dict.keys())
            
            # return
            if len(combobox_name.split("-")) <2:
                return
            click_combobox_time_stamp = int(combobox_name.split("-")[1])
            click_combobox_index_in_download_list = int(combobox_name.split("-")[-1])
            combobox_current_text = sender.currentText()
            print(combobox_current_text)
            #重新获取baseUrl
            this_horizontalLayout_dict = self.download_list[click_combobox_index_in_download_list]
            download_info_dict = this_horizontalLayout_dict['download_info_dict']
            id = -1
            if combobox_current_text == "1080P":
                id = 80
            elif combobox_current_text == "720P":
                id = 64
            elif combobox_current_text == "480P":
                id = 32
            elif combobox_current_text == "360P":
                id = 16
            else:
                self.log.error("未知的video_quality")
                return
            #然后获取baseUrl
            download_url_dict = download_info_dict['download_url_dict']
            video_dw_url_list = download_url_dict['video_dw_url_list']
            # print(video_dw_url_list)
            baseUrl = ""
            for dw in video_dw_url_list:
                if dw['id'] == id:
                    baseUrl = dw['baseUrl']
                    break
            if baseUrl == "":
                self.log.error("baseUrl为空")
                return
            # return
            #然后就是更新prime_download_info_dict
            prime_download_info_dict = this_horizontalLayout_dict['prime_download_info_dict']
            prime_download_info_dict['download_video_url'] = baseUrl
            #需要重新获取一下total_size,只获取video的即可
            video_total_size = DownloadUtilClass().get_single_file_total_size(baseUrl)
            prime_download_info_dict['total_video_size'] = video_total_size
            prime_download_info_dict['total_size'] = prime_download_info_dict['total_video_size'] + \
                                            prime_download_info_dict['total_audio_size']
            #然后更新download_thread
            self.set_per_url_download_thread(click_combobox_index_in_download_list)

    def refresh_download_list_when_parse_collection(self, url=None,index_in_collection=None):
        pass
        #将解析工作放到线程中进行
        url = self.collection_info_list[index_in_collection]['url']
        timestamp = time.time()
        # #将合集信息传入线程,让线程来逐个解析
        # downloadthread = DownloadThread(click_index=timestamp,collection_info_list=self.collection_info_list,\
        #                                 url=url, options="get_single_url_info_in_collection")
        downloadthread = DownloadThread(click_index=timestamp,collection_info_list=self.collection_info_list,\
                                        url=url, options="get_single_url_info_in_collection",\
                                        index_in_collection=index_in_collection, float_time_stamp=timestamp)
        downloadthread_dict = {}
        downloadthread_dict['options'] = "get_single_url_info_in_collection"
        downloadthread_dict['index'] = len(self.download_list)
        downloadthread_dict['thread'] = downloadthread
        downloadthread_dict['url'] = self.url
        downloadthread_dict['timestamp'] = timestamp #唯一标识
        self.thread_manager_dict[downloadthread_dict['timestamp']] = downloadthread_dict #用字典方便查找，后续删除也方便。
        #链接信号
        downloadthread.send_single_url_info_in_collection_finish_signal.connect(self.get_collection_single_url_info_finish_signal)
        #开启线程
        self.thread_manager_dict[timestamp]['thread'].start()
        self.log.warning(f"当前解析的url: {url}")

    #该函数就是封装好的查早单独url信息并更新download_lsit的方法
    def refresh_download_list(self):
        pass
        #将解析工作放到线程中进行
        timestamp = time.time()
        downloadthread = DownloadThread(click_index=timestamp, url=self.url, options="get_single_url_info")
        downloadthread_dict = {}
        downloadthread_dict['options'] = "get_single_url_info"
        downloadthread_dict['index'] = len(self.download_list)
        downloadthread_dict['thread'] = downloadthread
        downloadthread_dict['url'] = self.url
        downloadthread_dict['timestamp'] = timestamp #唯一标识
        self.thread_manager_dict[downloadthread_dict['timestamp']] = downloadthread_dict #用字典方便查找，后续删除也方便。
        #链接信号
        downloadthread.send_single_url_info_finish_signal.connect(self.get_single_url_info_finish_signal)
        #开启线程
        self.thread_manager_dict[timestamp]['thread'].start()

    def get_refresh_save_path_signal(self,index, err_dict):
        pass
        if err_dict !={}:
            self.log.error(f"更新save_path发生错误{err_dict['err_msg']}")
        else:
            self.log.info("更新save_path完毕")
        print(index)
        #清除线程
        for key in self.thread_manager_dict.keys():
            print(key)
            ds_key = None #记录需要删除的key
            if int(float(str(key).split("-")[0])) == index:
                ds_key = key
                break
        # self.thread_manager_dict.pop(key)
        thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
        del self.thread_manager_dict[ds_key]
        # 终止线程
        thread_to_destroy.terminate()
        # 检查线程的状态
        if thread_to_destroy.isFinished():
            self.log.error(f"线程{thread_to_destroy}已经结束")
            # 销毁线程对象
            thread_to_destroy.deleteLater()
        #检查一下
        print(self.thread_manager_dict)
        for key1 in self.thread_manager_dict.keys():
            print(key1)
        print(len(self.thread_manager_dict))
        #然后设置所有控件可用
        # self.enable_widgets()
        #==========
        #注意，同时还要更新dowload_thread中的save_path
        self.refresh_save_path_in_download_thread() #这样好像没有实际更改
        for i in range(len(self.download_list)):
            self.set_per_url_download_thread(i)

        self.disable_or_enable_widgets(True)
        return

    #更新所有下载线程的save_path
    def refresh_save_path_in_download_thread(self, download_list=None, index=None):
        pass
        #这里从self.thread_manager_dict中获取thread
        need_del_keys = []
        for key in self.thread_manager_dict.keys():
            if len(str(key).split("-")) == 2:
                if str(key).split("-")[1] == "download_thread":
                    need_del_keys.append(key)
                    #更改save_path
                    # download_thread = self.thread_manager_dict[key]['thread']
                    # old_save_path = download_thread.save_path
                    # file_name = old_save_path.split('/')[-1].split('\\')[-1]
                    # new_save_path = os.path.join(self.save_dir, file_name)
                    # download_thread.save_path = new_save_path
        #             #检查一下
        #             self.log.debug(f"thread_manager{self.thread_manager_dict[key]['thread'].save_path}")
        #清除线程
        for ds_key in need_del_keys:
            
            # self.thread_manager_dict.pop(key)
            thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
            del self.thread_manager_dict[ds_key]
            # 终止线程
            thread_to_destroy.terminate()
            # 检查线程的状态
            if thread_to_destroy.isFinished():
                self.log.error(f"线程{thread_to_destroy}已经结束")
                # 销毁线程对象
                thread_to_destroy.deleteLater()


    def get_refresh_download_list_signal(self, index, download_list):
        self.log.info(f"更新download_list结束, 来自线程{index}")
        # print(len(self.download_list))
        for i in self.download_list:
            pass
            # print(i['index_in_download_list'])    
        # self.single_url_parse_button.setEnabled(True) 这里不能设置,因为arrage_list里面用到了refresh_download_list
        #清除线程
        for key in self.thread_manager_dict.keys():
            # print(key)
            ds_key = None #记录需要删除的key
            if int(float(str(key).split("-")[0])) == index:
                ds_key = key
                break
        # self.thread_manager_dict.pop(key)
        thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
        del self.thread_manager_dict[ds_key]
        # 终止线程
        thread_to_destroy.terminate()
        # 检查线程的状态
        if thread_to_destroy.isFinished():
            self.log.error(f"线程{thread_to_destroy}已经结束")
            # 销毁线程对象
            thread_to_destroy.deleteLater()
        return


    def get_refresh_finish_signal_func(self):
        pass

    def get_download_thread_finish_signal(self, value_msg, click_index):
        pass

    def get_collection_info_finish_signal(self, horizontalDict):
        pass

    def get_single_url_info_finish_signal(self, value_msg, click_index):
        pass
        self.log.debug(f"parse_single_url结束{click_index}")
        # print("hhhh")
        # print(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        # print(type(click_index))
        for key in self.thread_manager_dict.keys():
            # print(type(key))
            
            if int(float(str(key).split("-")[0])) == click_index: #找到了 ,这里做一个split是为了区分download_thread,
                #因为我在utilclass中加入download_thread时，将time_stamp加了-download_thread
                #销毁线程
                self.log.info(f"销毁线程{self.thread_manager_dict[key]}")
                # 销毁指定线程
                thread_to_destroy = self.thread_manager_dict.get(key)['thread']
                if thread_to_destroy:
                    # thread_to_destroy.join()
                    del self.thread_manager_dict[key]
                    break

                # 打印当前字典中的线程数量
        # print(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        self.log.info(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        print(value_msg['parse_single_url'])
        #这个线程结束后，就需要对信息，即value_msg进行处理。这里可以直接add_progress_layout中的this_horizontalLayout_dict的
        #download_info_dict，然后有限选择的现在信息需要对这个信息进行进一步处理。例如默认设置combobox为最清晰，baseUrl为索引第1个等
        #并且设置index，title，page，bvid,等常用信息,这里就将这个value_msg直接传入add_progress_layout中，只用一个线程来解决。
        
        #判断是否发生错误
        err_dict = value_msg['err_dict']
        print(err_dict)
        print(err_dict!={})
        parse_single_url_err = ""
        if len(err_dict)!=0: #说明有错误
            self.log.error(f"解析连接{click_index}失败")
            for key in err_dict.keys():
                parse_single_url_err += str(err_dict[key]) + "--"
            #开消息盒子
            # QMessageLogUtilClass().show("提示", parse_single_url_err)
            self.disable_or_enable_widgets(True)
            return
        # return
        self.add_progress_layout(value_msg)
        self.disable_or_enable_widgets(True)
        return

    # def get_update_progressbar_signal(self, value_msg, click_index):
        pass

    #获取合集中的某个url解析完成的信号,因为一次开启多个线程还是吃不消,这里整备就是解析玩一个再开始下一个
    def get_collection_single_url_info_finish_signal(self, value_msg, index_in_collection, float_time_stamp):
        pass
        self.log.debug(f"parse_single_url_in_collection结束{index_in_collection}")
        # return
        for key in self.thread_manager_dict.keys():
            #这里解析collection中的url的线程是直接用float的时间戳机型
            if (float(str(key).split("-")[0])) == float_time_stamp: #找到了 ,这里做一个split是为了区分download_thread,
                #因为我在utilclass中加入download_thread时，将time_stamp加了-download_thread
                #销毁线程
                self.log.info(f"销毁线程{self.thread_manager_dict[key]}")
                # 销毁指定线程
                thread_to_destroy = self.thread_manager_dict.get(key)['thread']
                if thread_to_destroy:
                    # thread_to_destroy.join()
                    del self.thread_manager_dict[key]
                    break

                # 打印当前字典中的线程数量
        # print(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        self.log.info(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        print(value_msg['err_dict'])
        #这个线程结束后，就需要对信息，即value_msg进行处理。这里可以直接add_progress_layout中的this_horizontalLayout_dict的
        #download_info_dict，然后有限选择的现在信息需要对这个信息进行进一步处理。例如默认设置combobox为最清晰，baseUrl为索引第1个等
        #并且设置index，title，page，bvid,等常用信息,这里就将这个value_msg直接传入add_progress_layout中，只用一个线程来解决。
        
        #判断是否发生错误
        err_dict = value_msg['err_dict']
        print(err_dict)
        print(err_dict!={})
        parse_single_url_err = ""
        if len(err_dict)!=0: #说明有错误
            self.log.error(f"解析连接{index_in_collection}失败")
            for key in err_dict.keys():
                parse_single_url_err += str(err_dict[key]) + "--"
            #开消息盒子
            # QMessageLogUtilClass().show("提示", parse_single_url_err)
            return
        # return
        self.add_progress_layout(value_msg)
        #判断是否遍历完self.collection_info_list
        if index_in_collection == len(self.collection_info_list)-1: #说明已经遍历完
            self.log.info("遍历完合集")
            self.disable_or_enable_widgets(True)
            #同时设置self.collection_info_list为空
            self.collection_info_list = []
            #这里考虑到有很多线程了，就把不是download_thread的线程都销毁掉
            # #清除线程 前面我怀疑没有清掉，同时注意一定要在这是download_thread之前清理，不然会把download_thread也删除了
            thread_to_destroy = None
            # for key in self.thread_manager_dict.keys():
            #     # print(key)
            #     # ds_key = None #记录需要删除的key #注意这里可能会把set_download_thread_list中的key删除
            #     # print(key)
            #     if len(str(key).split("-")) == 2:
            #             if str(key).split("-")[1] == "download_thread":
            #         # if str(key).split("-")[1] != "-download_thread":
            #                 ds_key = key  
            #                 thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
            #                 del self.thread_manager_dict[ds_key]
            #                 # 终止线程
            #                 thread_to_destroy.terminate()
            #                 # 检查线程的状态
            #                 if thread_to_destroy.isFinished():
            #                     self.log.error(f"线程{thread_to_destroy}已经结束")
            #                     # 销毁线程对象
            #                     thread_to_destroy.deleteLater()

            return
        #然后开下一个线程
        self.log.warning(f"开启新的线程{index_in_collection+1}")
        self.refresh_download_list_when_parse_collection(index_in_collection=index_in_collection+1)
        return


    def get_update_progressbar_signal(self, value_msg, click_index):
        pass
        if "end" in value_msg.keys():
            for key,value in self.thread_manager_dict.items():
                if int(float(str(key).split("-")[0])) == int(click_index):
                    thread_to_destroy = self.thread_manager_dict.get(key)['thread']
                    # del thread_to_destroy
                    del self.thread_manager_dict[key]
                    # 终止线程
                    thread_to_destroy.terminate()
                    # 检查线程的状态
                    if thread_to_destroy.isFinished():
                        self.log.error(f"线程{thread_to_destroy}已经结束")
                        # 销毁线程对象
                        thread_to_destroy.deleteLater()
                        # self.thread_manager_dict
                    # self.multi_dw_keys.remove(str(click_index) + '-download_thread')
                    break
            #删除文件temp
            # 创建子线程并定义Lambda函数
            thread = threading.Thread(target=lambda: (time.sleep(5), os.remove((value_msg['save_video_temp_path']))))
            thread.start()
            thread = threading.Thread(target=lambda: (time.sleep(5), os.remove((value_msg['save_audio_temp_path']))))
            thread.start()
            # if os.path.exists(value_msg['save_video_temp_path']):
            #     lastmod = datetime.datetime.fromtimestamp(os.path.getmtime(LogFile)).strftime('%Y-%m-%d %H-%M-%S')
            #     copyfile(value_msg['save_video_temp_path'], 'Log/'+value_msg['save_video_temp_path'].replace('.txt',' '+lastmod+'.txt'))
            #     try:
            #         os.remove(LogFile)
            #     except: #PermissionError: [WinError 32] The process cannot access the file because it is being used by another process
            #         for proc in psutil.process_iter():
            #             if proc.name() == 'python.exe':
            #                 proc.kill()
            #         os.remove(LogFile)
            # try:
            #     os.system(f"attrib -r {value_msg['save_video_temp_path']}")
            #     # os.system(f"attrib -r {value_msg['save_audio_temp_path']}")
            #     os.remove(value_msg['save_video_temp_path'])
            #     # os.remove(value_msg['save_audio_temp_path'])
            # except Exception as e:
            #     self.log.error(f"删除文件{value_msg['save_video_temp_path']}失败，错误信息为{e}")
            #     # self.log.error(f"删除文件{value_msg['save_audio_temp_path']}失败，错误信息为{e}")
            
            # try:
            #     # os.system(f"attrib -r {value_msg['save_video_temp_path']}")
            #     os.system(f"attrib -r {value_msg['save_audio_temp_path']}")
            #     # os.remove(value_msg['save_video_temp_path'])
            #     os.remove(value_msg['save_audio_temp_path'])
            # except Exception as e:
            #     # self.log.error(f"删除文件{value_msg['save_video_temp_path']}失败，错误信息为{e}")
            #     self.log.error(f"删除文件{value_msg['save_audio_temp_path']}失败，错误信息为{e}")
            # print(value_msg['save_video_temp_path'].replace('\\\\','/'))
            # shutil.rmtree(value_msg['save_video_temp_path'].replace('\\\\','/')) #即可解决
            # shutil.rmtree(value_msg['save_audio_temp_path'].replace('\\\\','/')) #即可解决
            #然后判断是否为多线程下载
            self.log.debug("开始多线程检测")
            print(self.dw_index)
            print(len(self.download_list))
            print(self.is_multi_thread_download)
            if self.is_multi_thread_download and (self.dw_index!=len(self.download_list)):
                # key = list(self.thread_manager_dict.keys())
                # self.thread_manager_dict[key].start()
                # index_in_download_list = self.thread_manager_dict[self.multi_dw_keys[0]]['index']
                self.log.debug("开始多线程下载下一个")
                self.start_or_pause_download_when_multi_thread(self.dw_index)
                self.dw_index+=1
            else:
                self.is_multi_thread_download = False
                # del self.multi_dw_keys
                # del self.dw_index
                self.log.info("多线程下载结束")
                return
            return
        # self.log.debug("我被调用了")
        # print(value_msg)
        #先找到对应的horizontalLayout
        click_horizontalLayout = None
        for horizontalLayout_dict in self.download_list:
            if horizontalLayout_dict['this_horizontalLayout_create_time'] == click_index:
                #找到horizontalLayout
                click_horizontalLayout = horizontalLayout_dict['this_horizontalLayout_layout_dict']
                break    
        progress_label = None
        progressBar = None
        #找到控件
        progressBar = click_horizontalLayout['progressBar']
        progress_label = click_horizontalLayout['progress_label']
        start_or_pause_button = click_horizontalLayout['start_or_pause_button']
        if progress_label==None or progressBar==None:
            self.log.warning(f"没找到progress_lable {str(click_index)} 或者 progressBar {str(click_index)}")
            return
        progress_label.setText(value_msg['progress_label_value'])
        progressBar.setValue(int(value_msg['progressBar_value']))
        # progressBar.setValue(2)
        if value_msg['progressBar_value'] >=100:
            #设置下载结束按钮文本并禁用按钮
            start_or_pause_button.setText("下载完成")
            start_or_pause_button.setEnabled(False)
            #下载结束就需要将线程给结束掉，销毁对应download_thread
            #这里还不能立即删除线程，因为还需要ffmpeg合成，如果删除就无法合成了
            #这里的做法是加一个结束信号

            # if "end" in value_msg.keys():
            #     for key,value in self.thread_manager_dict.items():
            #         if int(float(str(key).split("-")[0])) == int(click_index):
            #             thread_to_destroy = self.thread_manager_dict.get(key)['thread']
            #             # del thread_to_destroy
            #             del self.thread_manager_dict[key]
            #             # 终止线程
            #             thread_to_destroy.terminate()
            #             # 检查线程的状态
            #             if thread_to_destroy.isFinished():
            #                 self.log.error(f"线程{thread_to_destroy}已经结束")
            #                 # 销毁线程对象
            #                 thread_to_destroy.deleteLater()
            #             break


    
    def get_arrage_finish_signal(self,index_timestamp=None, horizontaldict=None, dw_list =None):
        pass
        '''
        #销毁线程，这就不对了，问题就出在这，因为之前再UtilClass中绑定download_thread的时候，将download_thread按照time_stamp放入
        self.thread_manager_dict中，而utilClass和download_thread的time_stamp都是this_horizontallayout的time_stamp，所以在加入
        download_thread到self.thread_manager_dict的时候，就会覆盖掉原来加如的utilclass_thread，然而这里在将download_thread从thread
        _manager_dict中删除，就会导致this_horizontal_dict中的download_thread也被删除了，所以点击按钮发送信号就接收不到
        '''
        for key,value in self.thread_manager_dict.items():
            if int(float(str(key).split("-")[0])) == int(index_timestamp):
                thread_to_destroy = self.thread_manager_dict.get(key)['thread']
                # del thread_to_destroy
                del self.thread_manager_dict[key]
                # 终止线程
                thread_to_destroy.terminate()
                # 检查线程的状态
                if thread_to_destroy.isFinished():
                    self.log.error(f"线程{thread_to_destroy}已经结束")
                    # 销毁线程对象
                    thread_to_destroy.deleteLater()
                break
        # #清除线程 前面我怀疑没有清掉，同时注意一定要在这是download_thread之前清理，不然会把download_thread也删除了
        thread_to_destroy = None
        for key in self.thread_manager_dict.keys():
            # print(key)
            ds_key = None #记录需要删除的key #注意这里可能会把set_download_thread_list中的key删除
            # print(key)
            if int(float(str(key).split("-")[0])) == index_timestamp:
                # if str(key).split("-")[1] != "-download_thread":
                    ds_key = key  
                    break
        # self.thread_manager_dict.pop(key)
        if thread_to_destroy is not None: #这里之前没设置就出现bug了，程序卡折不动也不报错
            thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
            del self.thread_manager_dict[ds_key]
            # 终止线程
            thread_to_destroy.terminate()
            # 检查线程的状态
            if thread_to_destroy.isFinished():
                self.log.error(f"线程{thread_to_destroy}已经结束")
                # 销毁线程对象
                thread_to_destroy.deleteLater()
            
        self.log.info(f"当前字典中的线程数量: {len(self.thread_manager_dict)}")
        self.log.info(f"整理结束,来自UtilClass线程,time_stamp: {index_timestamp}")
        #在这里对开始下载按钮进行一下绑定，之前再UtilClass中绑定没有生效
        index_in_donwload_list = horizontaldict['index_in_download_list']
        # self.log.error(f"downlaod_thread的download_video为:{self.download_list[index_in_donwload_list]['download_thread'].get_pause_download_signal}")
        self.set_per_url_download_thread(index_in_donwload_list)

        
        # donwload_thread = horizontaldict['download_thread']
        # self.log.error(f"downlaod_thread的download_video为:{donwload_thread.download_video_url}")
        # # donwload_thread_in_download_list = DownloadThread(-1)
        # donwload_thread_in_download_list = self.download_list[index_in_donwload_list]['download_thread']
        # self.log.warning(f"self.download_list中的当前horizongtaldict的下载线程为{donwload_thread_in_download_list}")
        # self.log.warning(f"self.download_list中的当前horizongtaldict的下载线程为\
        #                  {self.download_list[index_in_donwload_list]['download_thread']}")
        # #开始绑定信号
        # self.pause_download_signal.connect(donwload_thread_in_download_list.get_pause_download_signal)
        # self.log.warning(f"传回来的horizontalDict中的下载线程为{donwload_thread}")


        #然后让布局显示
        #这里要考虑正在解析合集的情况
        # if len(self.collection_info_list) == 0:
        this_horizontalLayout = horizontaldict['this_horizontalLayout_layout_dict']['horizontalLayout']
        for index in range(this_horizontalLayout.count()):
            item = this_horizontalLayout.itemAt(index)
            item_widget = item.widget()
            item_widget.setVisible(True)
            if isinstance(item_widget, QPushButton) and len(self.collection_info_list) !=0:
                item_widget.setEnabled(False)
        self.log.error(f"当前的下载列表长度为{len(self.download_list)}")
        #到这里单次解析url才结束
        #这里要考虑正在解析合集的情况
        if len(self.collection_info_list) == 0:
            # self.single_url_parse_button.setEnabled(True)
            self.disable_or_enable_widgets(True)

        # #清除线程
        # for key in self.thread_manager_dict.keys():
        #     # print(key)
        #     ds_key = None #记录需要删除的key #注意这里可能会把set_download_thread_list中的key删除
        #     if int(float(str(key).split("-")[0])) == index_timestamp:
        #         ds_key = key  
        #         break
        # # self.thread_manager_dict.pop(key)
        # thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
        # del self.thread_manager_dict[ds_key]
        # # 终止线程
        # thread_to_destroy.terminate()
        # # 检查线程的状态
        # if thread_to_destroy.isFinished():
        #     self.log.error(f"线程{thread_to_destroy}已经结束")
        #     # 销毁线程对象
        #     thread_to_destroy.deleteLater()
    
    def get_parse_collection_finish_signal(self,index,collection_info_list):
        pass
        self.log.info(f"{index}获取到合集信息")
        print(len(collection_info_list))
        print((collection_info_list))
        # return
        self.collection_info_list = collection_info_list
        #尝试获取和集中每个的url,用于后续的逐个解析
        try:
            for per_url_info in self.collection_info_list:
                if per_url_info['page'] != "" and per_url_info['page'] !=1:
                    # url = "https://www.bilibili.com/video/" + per_url_info['bvid'] + "?" + str(per_url_info['page'])
                    # url = "https://www.bilibili.com/video/" + per_url_info['bvid'] + "?p=" + str(per_url_info['page'])
                    url = "https://www.bilibili.com/video/" + per_url_info['bvid'] + "/?p=" + str(per_url_info['page'])
                else:
                    url = "https://www.bilibili.com/video/" + per_url_info['bvid']
                # self.input_url = url
                # self.parse_single_url()
                # break
                per_url_info['url'] = url
        except Exception as e:
            self.log.error(e)
            QMessageLogUtilClass().show("合集解析失败")
        #这里获取了说有url,开始逐个解析
        self.parse_per_url_in_collection_list()

        #清除线程
        for key in self.thread_manager_dict.keys():
            # print(key)
            ds_key = None #记录需要删除的key
            if int(float(str(key).split("-")[0])) == index:
                ds_key = key
                break
        # self.thread_manager_dict.pop(key)
        thread_to_destroy = self.thread_manager_dict[ds_key]['thread']
        del self.thread_manager_dict[ds_key]
        # 终止线程
        thread_to_destroy.terminate()
        # 检查线程的状态
        if thread_to_destroy.isFinished():
            self.log.error(f"线程{thread_to_destroy}已经结束")
            # 销毁线程对象
            thread_to_destroy.deleteLater()
        #
        #由于再add_layout中设置了self.parse_single_button为true
        #所以这里再设置一下

    def set_per_url_download_thread(self, index_in_download_list):
        # prime_download_info_dict = {
        #         "title":title,
        #         "bvid":bvid,
        #         "page":page,
        #         "best_quality":best_quality,
        #         "id_baseUrl_dict":id_baseUrl_dict,
        #         "download_video_url":download_video_url,
        #         "download_audio_url":download_audio_url,
        #         "total_video_size":total_video_size,
        #         "total_audio_size":total_audio_size,
        #         "total_size":total_size,
        #         "save_path":save_path,
        #     }
        pass
        this_horizontalLayout_dict = self.download_list[index_in_download_list]
        this_prime_download_info_dict = this_horizontalLayout_dict["prime_download_info_dict"]
        this_horizontalLayout_create_time = this_horizontalLayout_dict['this_horizontalLayout_create_time']
        download_video_url = this_prime_download_info_dict['download_video_url']
        download_audio_url = this_prime_download_info_dict['download_audio_url']
        # self.log.info(f"当前设置set_download_thread,audio_url为{download_audio_url}")
        total_size = this_prime_download_info_dict['total_size']
        save_path = this_prime_download_info_dict['save_path']

        #在utilclass设置download_thread后存储在horizontallayout的dict中不太行，尝试单独开一个线程来设置
        self.log.error(save_path)
        self.log.error(self.save_dir)
        download_thread = DownloadThread(video_url=download_video_url, audio_url=download_audio_url, save_path=save_path,\
                                            click_index= this_horizontalLayout_create_time, total_size=total_size,\
                                            options="download_single", download_file_type="video_and_audio",\
                                            is_pause=True)
        # download_thread.progressChanged.connect(self.get_update_progressbar_signal)
        #这里同样将download_thread放入thread_manager_dict
        download_thread_dict = {}
        download_thread_dict['options'] = "download_thread"
        download_thread_dict['index'] = len(self.download_list)
        download_thread_dict['thread'] = download_thread
        download_thread_dict['url'] = download_video_url
        download_thread_dict['timestamp'] = this_horizontalLayout_create_time #唯一标识
        #将下载线程加入self.thread_manager_dict中
        self.thread_manager_dict[str(this_horizontalLayout_create_time)+'-'+"download_thread"] = download_thread_dict
        #链接自己的暂停和下载信号
        self.log.info(f"开始绑定pause_download_signal")
        # self.pause_download_signal.connect(download_thread.get_pause_download_signal)
        self.pause_download_signal.connect(download_thread.get_pause_download_signal)
        download_thread.progressChanged_signal.connect(self.get_update_progressbar_signal) #设置一下进度条更新
        self.log.info(f"绑定pause_download_signal成功")
        this_horizontalLayout_dict['download_thread'] = download_thread
        # print(this_horizontalLayout_dict['download_thread'].download_video_url)
        # print(this_horizontalLayout_dict['download_thread'].get_pause_download_signal)
        # print(self.receive_signal_dict['get_refresh_finish_signal_func'])
        return




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Form = QtWidgets.QWidget()
    ui = Ui_Form()
    ui.setupUi(Form)
    Form.show()
    sys.exit(app.exec_())
